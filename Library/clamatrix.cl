/* ------------------------------------------------------------
 * This is the file "clamatrix.cl" of this master thesis.
 * All rights reserved, Steffen Boerm 2009
 * ------------------------------------------------------------ */

/**
 * @file      cl/clamatrix.cl
 * @author    Bennet Carstensen
 * @date      2017
 * @copyright All rights reserved, Steffen Boerm 2009
 */

#ifndef CLAMATRIX_CL
#define CLAMATRIX_CL

/** @addtogroup amatrix
 *  @{ */

/*  @brief The source code to performe operations on the module
 *         @ref amatrix via OpenCL as a string. */
static const char clamatrix_src[] =
{
  "#ifndef CLAMATRIX_CL\n"
  "#define CLAMATRIX_CL\n"
  "\n"
  "\n"
  "\n"
  "typedef struct _amatrix amatrix;\n"
  "\n"
  "typedef amatrix *pamatrix;\n"
  "\n"
  "typedef const amatrix *pcamatrix;\n"
  "\n"
  "struct _amatrix {\n"
  "  /** @brief Matrix coefficients in column-major order, i.e., @f$a_{ij}@f$\n"
  "    *        corresponds to `a[i+j*ld]`.  */\n"
  "  global field *a;\n"
  "\n"
  "  /** @brief Leading dimension, i.e., increment used to switch from one column\n"
  "    *        to the next.  */\n"
  "  size_t ld;\n"
  "\n"
  "  /** @brief Number of rows. */\n"
  "  size_t rows;\n"
  "  /** @brief Number of columns.  */\n"
  "  size_t cols;\n"
  "};\n"
  "\n"
  "pamatrix\n"
  "new_amatrix(global field *a, size_t rows, size_t cols)\n"
  "{\n"
  "  amatrix m;\n"
  "\n"
  "  m.a    = a;\n"
  "  m.ld   = rows;\n"
  "  m.rows = rows;\n"
  "  m.cols = cols;\n"
  "\n"
  "  return &m;\n"
  "}\n"
  "\n"
  "void\n"
  "print_amatrix(pcamatrix a)\n"
  "{\n"
  "  size_t rows = a->rows;\n"
  "  size_t cols = a->cols;\n"
  "  size_t lda = a->ld;\n"
  "\n"
  "  if((get_local_id(0) == 0) && (get_local_id(1) == 0) && (get_local_id(2) == 0))\n"
  "  {\n"
  "    (void) printf(\"amatrix(%u,%u,%u)\\n\", rows, cols, a->ld);\n"
  "    if (rows == 0 || cols == 0)\n"
  "      return;\n"
  "\n"
  "    for(size_t i = 0; i < rows; i++) {\n"
  "      (void) printf(\"  (%.5e\", a->a[i]);\n"
  "      for(size_t j = 1; j < cols; j++)\n"
  "        (void) printf(\" | %.5e\", a->a[i + j * lda]);\n"
  "      (void) printf(\")\\n\");\n"
  "    }\n"
  "  }\n"
  "}\n"
  "\n"
  "void\n"
  "addeval_amatrix_avector(field alpha, pcamatrix a, pcavector src, pavector trg)\n"
  "{\n"
  "  const size_t lcl_size = get_local_size(0);\n"
  "  const size_t lcl_id   = get_local_id(0);\n"
  "\n"
  "  const size_t rows = a->rows;\n"
  "  const size_t cols = a->cols;\n"
  "\n"
  "  /* Number of iterations, where ALL threads perform. */\n"
  "  const size_t n    = (size_t) floor((real) rows / (real) lcl_size);\n"
  "\n"
  "  /* Calculate lcl_size entries of the result vector at once. */\n"
  "  for(size_t k = 0; k < n; ++k)\n"
  "  {\n"
  "    const size_t i = lcl_size * k + lcl_id; // Row index\n"
  "\n"
  "    field y = f_zero;\n"
  "\n"
  "    for(size_t j = 0; j < cols; ++j)\n"
  "      y += a->a[i + j * rows] * src->v[j];\n"
  "\n"
  "    trg->v[i] += alpha * y;\n"
  "  }\n"
  "\n"
  "  /* Calculate the remaining entries of the result vector. */\n"
  "  if(lcl_id < (rows - n * lcl_size))\n"
  "  {\n"
  "    const size_t i = lcl_size * n + lcl_id;\n"
  "\n"
  "    field y = f_zero;\n"
  "\n"
  "    for(size_t j = 0; j < cols; ++j)\n"
  "      y += a->a[i + j * rows] * src->v[j];\n"
  "\n"
  "    trg->v[i] += alpha * y;\n"
  "  }\n"
  "}\n"
  "\n"
  "void\n"
  "addevaltrans_amatrix_avector(field     alpha,\n"
  "                             pcamatrix a,\n"
  "                             pcavector src,\n"
  "                             pavector trg)\n"
  "{\n"
  "  const size_t lcl_size = get_local_size(0);\n"
  "  const size_t lcl_id   = get_local_id(0);\n"
  "\n"
  "  const size_t rows = a->rows;\n"
  "  const size_t cols = a->cols;\n"
  "\n"
  "  /* Number of iterations, where ALL threads perform. */\n"
  "  const size_t n    = (size_t) floor((real) cols / (real) lcl_size);\n"
  "\n"
  "  /* Calculate lcl_size entries of the result vector at once. */\n"
  "  for(size_t k = 0; k < n; ++k)\n"
  "  {\n"
  "    const size_t j = lcl_size * k + lcl_id; // Row index\n"
  "\n"
  "    field y = f_zero;\n"
  "\n"
  "    for(size_t i = 0; i < rows; ++i)\n"
  "      y += a->a[i + j * rows] * src->v[i];\n"
  "\n"
  "    trg->v[j] += alpha * y;\n"
  "  }\n"
  "\n"
  "  /* Calculate the remaining entries of the result vector. */\n"
  "  if(lcl_id < (cols - n * lcl_size))\n"
  "  {\n"
  "    const size_t j = lcl_size * n + lcl_id;\n"
  "\n"
  "    field y = f_zero;\n"
  "\n"
  "    for(size_t i = 0; i < rows; ++i)\n"
  "      y += a->a[i + j * rows] * src->v[i];\n"
  "\n"
  "    trg->v[j] += alpha * y;\n"
  "  }\n"
  "}\n"
  "\n"
  "void\n"
  "mvm_amatrix_avector(field     alpha,\n"
  "                    bool      atrans,\n"
  "                    pcamatrix a,\n"
  "                    pcavector src,\n"
  "                    pavector  trg)\n"
  "{\n"
  "  if(atrans)\n"
  "    addevaltrans_amatrix_avector(alpha, a, src, trg);\n"
  "  else\n"
  "    addeval_amatrix_avector(alpha, a, src, trg);\n"
  "}\n"
  "\n"
  "// kernel void\n"
  "// mvm_amatrices_avectors(global field *alphas,\n"
  "//                        global bool  *atrans,\n"
  "//                        global field *as,\n"
  "//                        global uint  *as_off,\n"
  "//                        global uint  *n_rows,\n"
  "//                        global uint  *n_cols,\n"
  "//                        global field *srcs,\n"
  "//                        global uint  *srcs_off,\n"
  "//                        global field *trgs,\n"
  "//                        global uint  *trgs_off)\n"
  "// {\n"
  "//   const size_t grp_id = get_group_id(0);\n"
  "//\n"
  "//   const size_t rows   = n_rows[grp_id];\n"
  "//   const size_t cols   = n_cols[grp_id];\n"
  "//\n"
  "//   const bool   trans  = atrans[grp_id];\n"
  "//\n"
  "//   pamatrix a   = new_amatrix(as + as_off[grp_id], rows, cols);\n"
  "//   pavector src = new_avector(srcs + srcs_off[grp_id], trans ? rows : cols);\n"
  "//   pavector trg = new_avector(trgs + trgs_off[grp_id], trans ? cols : rows);\n"
  "//\n"
  "//   if(get_group_id(0) == 0)\n"
  "//     printf(\"%u\\n\", trgs_off[grp_id]);\n"
  "//\n"
  "//   mvm_amatrix_avector(1.0, trans, a, src, trg);\n"
  "// }\n"
  "\n"
  "\n"
  "#endif // CLAMATRIX_CL\n"
};

/** @} */

#endif // CLAMATRIX_CL