/* ------------------------------------------------------------
 * This is the file "clfastaddeval.cl" of this master thesis.
 * All rights reserved, Bennet Carstensen 2017
 * ------------------------------------------------------------ */

/**
 * @file      cl/clfastaddeval.cl
 * @author    Bennet Carstensen
 * @date      2017
 * @copyright All rights reserved, Bennet Carstensen 2017
 */

#ifndef CLFASTADDEVALGCA_CL
#define CLFASTADDEVALGCA_CL

/** @addtogroup fastaddevalgca
 *  @{ */

/*  @brief The source code to performe operations on the module
 *         @ref fastaddevalgca via OpenCL as a string. */
static const char clfastaddevalgca_src[] =
{
  "\n"
  "#ifndef FASTADDEVAL_CL\n"
  "#define FASTADDEVAL_CL\n"
  "\n"
  "void\n"
  "fastaddeval_farfield(pgcidxinfo gcii, pgeom sur, psingquadg sq,\n"
  "                     private const real bem_alpha,\n"
  "                     private const real kernel_factor,\n"
  "                     private const real alpha)\n"
  "{\n"
  "  const size_t lid0 = get_local_id(0);\n"
  "\n"
  "  for(uint i = 0; i < gcii->ridx_size; ++i)\n"
  "  {\n"
  "    const uint ii = gcii->ridx[i];\n"
  "\n"
  "    const real  gr = sur->g[ii];\n"
  "\n"
  "    const uint3 q  = vload3(ii, sur->p);\n"
  "\n"
  "    private real3 x[3];\n"
  "\n"
  "    x[0] = vload3(q.x, sur->v);\n"
  "    x[1] = vload3(q.y, sur->v);\n"
  "    x[2] = vload3(q.z, sur->v);\n"
  "\n"
  "    // const real yt_i = gcii->yt[i];\n"
  "\n"
  "    real res = r_zero;\n"
  "\n"
  "    for(uint j = 0; j < gcii->cidx_size; ++j)\n"
  "    {\n"
  "      const uint  jj = gcii->cidx[j];\n"
  "\n"
  "      const real  gc = sur->g[jj];\n"
  "      const uint3 p  = vload3(jj, sur->p);\n"
  "\n"
  "      const real factor = (ii == jj) * 0.5 * bem_alpha * gr;\n"
  "\n"
  "      private real3 y[3];\n"
  "\n"
  "      y[0] = vload3(p.x, sur->v);\n"
  "      y[1] = vload3(p.y, sur->v);\n"
  "      y[2] = vload3(p.z, sur->v);\n"
  "\n"
  "      real sum = sq->bases.x;\n"
  "\n"
  "      for(uint q = 0; q < sq->nq; ++q)\n"
  "      {\n"
  "        float s, t;\n"
  "\n"
  "#ifndef USE_FLOAT\n"
  "        t  = convert_float(sq->xqs[q]);\n"
  "        s  = convert_float(sq->xqs[q + sq->nq]);\n"
  "\n"
  "        private float3 xx, yy;\n"
  "\n"
  "        xx = (1.0f - t) * convert_float3(x[0]) +\n"
  "             (t - s)    * convert_float3(x[1]) +\n"
  "             s          * convert_float3(x[2]);\n"
  "\n"
  "        t  = convert_float(sq->yqs[q]);\n"
  "        s  = convert_float(sq->yqs[q + sq->nq]);\n"
  "\n"
  "        yy = (1.0f - t) * convert_float3(y[0]) +\n"
  "             (t - s)    * convert_float3(y[1]) +\n"
  "             s          * convert_float3(y[2]);\n"
  "#else\n"
  "        t  = sq->xqs[q];\n"
  "        s  = sq->xqs[q + sq->nq];\n"
  "\n"
  "        private float3 xx, yy;\n"
  "\n"
  "        xx = (r_one - t) * x[0] + (t - s) * x[1] + s * x[2];\n"
  "\n"
  "        t  = sq->yqs[q];\n"
  "        s  = sq->yqs[q + sq->nq];\n"
  "\n"
  "        yy = (r_one - t) * y[0] + (t - s) * y[1] + s * y[2];\n"
  "#endif\n"
  "\n"
  "        sum += sq->wqs[q] * laplace3d(xx, yy);\n"
  "      }\n"
  "\n"
  "      res += gcii->xt[j] * ((gc * gr * kernel_factor * sum) + factor);\n"
  "    }\n"
  "\n"
  "    for(uint j = 0; j < gcii->num_h2_leafs; ++j)\n"
  "    {\n"
  "      barrier(CLK_GLOBAL_MEM_FENCE);\n"
  "\n"
  "      if(lid0 == j)\n"
  "        gcii->yt[i] += alpha * res;\n"
  "    }\n"
  "  }\n"
  "}\n"
  "\n"
  "// bool buf_switch = 0;\n"
  "//\n"
  "// for(uint k = 0; k < sq->nq; k += SIZE)\n"
  "// {\n"
  "//   const size_t size = (k + SIZE) < sq->nq ? SIZE : sq->nq - k;\n"
  "//\n"
  "//   local real *xq, *yq, *wq;\n"
  "//\n"
  "//   event_t *events;\n"
  "//\n"
  "//   if((sq->nq - k - size) > 0)\n"
  "//   {\n"
  "//     xq = sq->xqs_buf + (2 + 2 * buf_switch) * SIZE;\n"
  "//     yq = sq->yqs_buf + (2 + 2 * buf_switch) * SIZE;\n"
  "//     wq = sq->wqs_buf + (1 + 1 * buf_switch) * SIZE;\n"
  "//\n"
  "//     events      = sq->events + 5 * buf_switch;\n"
  "//\n"
  "//     const size_t next = (k + 2 * SIZE) < sq->nq ? SIZE : sq - (k + SIZE);\n"
  "//\n"
  "//     events[0] = async_work_group_copy(xq,        sq->xqs + k + SIZE,          next, 0);\n"
  "//     events[1] = async_work_group_copy(xq + SIZE, sq->xqs + sq->nq + k + SIZE, next, 0);\n"
  "//     events[2] = async_work_group_copy(yq,        sq->yqs + k + SIZE,          next, 0);\n"
  "//     events[3] = async_work_group_copy(yq + SIZE, sq->yqs + sq->nq + k + SIZE, next, 0);\n"
  "//     events[4] = async_work_group_copy(wq,        sq->wqs + k + SIZE,          next, 0);\n"
  "//   }\n"
  "//\n"
  "//   buf_switch = !buf_switch;\n"
  "//\n"
  "//   xq = sq->xqs_buf + (k != 0) * (2 + 2 * buf_switch) * SIZE;\n"
  "//   yq = sq->yqs_buf + (k != 0) * (2 + 2 * buf_switch) * SIZE;\n"
  "//   wq = sq->wqs_buf + (k != 0) * (1 + 1 * buf_switch) * SIZE;\n"
  "//\n"
  "//   events = sq->events + 5 * buf_switch;\n"
  "//\n"
  "//   wait_group_events(5, events);\n"
  "//\n"
  "//   for(uint q = 0; q < size; ++q)\n"
  "//   {\n"
  "//     const float w = wq[q];\n"
  "//\n"
  "//     float s, t;\n"
  "//\n"
  "// #ifndef USE_FLOAT\n"
  "//     t  = convert_float(xq[q]);\n"
  "//     s  = convert_float(xq[q + SIZE]);\n"
  "//\n"
  "//     if(get_global_id(0) == 0 && i == 0 && j == 0)\n"
  "//       printf(\"%u: %.5e %.5e \", k + q, t, s);\n"
  "//\n"
  "//     private float3 xx, yy;\n"
  "//\n"
  "//     xx = (1.0f - t) * convert_float3(x[0]) +\n"
  "//          (t - s)    * convert_float3(x[1]) +\n"
  "//          s          * convert_float3(x[2]);\n"
  "//\n"
  "//     t  = convert_float(yq[q]);\n"
  "//     s  = convert_float(yq[q + SIZE]);\n"
  "//\n"
  "//     if(get_global_id(0) == 0 && i == 0 && j == 0)\n"
  "//       printf(\"%.5e %.5e %.5e\\n\",  t, s, wq[q]);\n"
  "//\n"
  "//     yy = (1.0f - t) * convert_float3(y[0]) +\n"
  "//          (t - s)    * convert_float3(y[1]) +\n"
  "//          s          * convert_float3(y[2]);\n"
  "// #else\n"
  "//     t  = sq->xqs[q];\n"
  "//     s  = sq->xqs[q + sq->nq];\n"
  "//\n"
  "//     xx = (r_one - t) * x[0] + (t - s) * x[1] + s * x[2];\n"
  "//\n"
  "//     t  = yq[q];\n"
  "//     s  = yq[q + quad->nq];\n"
  "//\n"
  "//     yy = (r_one - t) * y[yp[0]] + (t - s) * y[yp[1]] + s * y[yp[2]];\n"
  "// #endif\n"
  "//\n"
  "//     sum += w * laplace3d(xx, yy);\n"
  "//   }\n"
  "// }\n"
  "\n"
  "void\n"
  "fastaddeval_farfield_back(pgcidxinfo gcii, pgeom sur, psingquadl sq,\n"
  "                         private const real bem_alpha,\n"
  "                         private const real kernel_factor,\n"
  "                         private const real alpha)\n"
  "{\n"
  "  // prefetch(sq->xqs, 2 * QUADRATUR_ORDER);\n"
  "  // prefetch(sq->yqs, 2 * QUADRATUR_ORDER);\n"
  "  // prefetch(sq->wqs,     QUADRATUR_ORDER);\n"
  "\n"
  "  wait_group_events(3, sq->events);\n"
  "\n"
  "  for(uint i = 0; i < gcii->ridx_size; ++i)\n"
  "  {\n"
  "    const uint ii = gcii->ridx[i];\n"
  "\n"
  "    const real  gr = sur->g[ii];\n"
  "\n"
  "    const uint3 q  = vload3(ii, sur->p);\n"
  "\n"
  "    private real3 x[3];\n"
  "\n"
  "    x[0] = vload3(q.x, sur->v);\n"
  "    x[1] = vload3(q.y, sur->v);\n"
  "    x[2] = vload3(q.z, sur->v);\n"
  "\n"
  "    real res = r_zero;\n"
  "\n"
  "    for(uint j = 0; j < gcii->cidx_size; ++j)\n"
  "    {\n"
  "      const uint  jj = gcii->cidx[j];\n"
  "\n"
  "      const real  gc = sur->g[jj];\n"
  "      const uint3 p  = vload3(jj, sur->p);\n"
  "\n"
  "      const real factor = (ii == jj) * 0.5 * bem_alpha * gr;\n"
  "\n"
  "      private real3 y[3];\n"
  "\n"
  "      y[0] = vload3(p.x, sur->v);\n"
  "      y[1] = vload3(p.y, sur->v);\n"
  "      y[2] = vload3(p.z, sur->v);\n"
  "\n"
  "      real sum = sq->bases.x;\n"
  "\n"
  "      uint q = 0;\n"
  "\n"
  "#ifndef USE_FLOAT\n"
  "      for(; (q + 2) < sq->nq; q += 2)\n"
  "      {\n"
  "        real2  tmp = vload2(q / 2, sq->xqs);\n"
  "        float2 t   = { convert_float(tmp.x), convert_float(tmp.y) };\n"
  "\n"
  "        tmp        = vload2(q / 2, sq->xqs + sq->nq);\n"
  "        float2 s   = { convert_float(tmp.x), convert_float(tmp.y) };\n"
  "\n"
  "        private float2 xx[3] = { { 0.0f, 0.0f },\n"
  "                                 { 0.0f, 0.0f },\n"
  "                                 { 0.0f, 0.0f } };\n"
  "\n"
  "        float scalar = 0.0f;\n"
  "\n"
  "        scalar = convert_float(x[0].x); xx[0] = (1.0f - t) * scalar;\n"
  "        scalar = convert_float(x[0].y); xx[1] = (1.0f - t) * scalar;\n"
  "        scalar = convert_float(x[0].z); xx[2] = (1.0f - t) * scalar;\n"
  "\n"
  "        scalar = convert_float(x[1].x); xx[0] = mad(t - s, scalar, xx[0]);\n"
  "        scalar = convert_float(x[1].y); xx[1] = mad(t - s, scalar, xx[1]);\n"
  "        scalar = convert_float(x[1].z); xx[2] = mad(t - s, scalar, xx[2]);\n"
  "\n"
  "        scalar = convert_float(x[2].x); xx[0] = mad(s,     scalar, xx[0]);\n"
  "        scalar = convert_float(x[2].y); xx[1] = mad(s,     scalar, xx[1]);\n"
  "        scalar = convert_float(x[2].z); xx[2] = mad(s,     scalar, xx[2]);\n"
  "\n"
  "        tmp = vload2(q / 2, sq->yqs);\n"
  "        t   = ( convert_float(tmp.x), convert_float(tmp.y) );\n"
  "\n"
  "        tmp = vload2(q / 2, sq->yqs + sq->nq);\n"
  "        s   = ( convert_float(tmp.x), convert_float(tmp.y) );\n"
  "\n"
  "        private float2 yy[3] = { { 0.0f, 0.0f },\n"
  "                                 { 0.0f, 0.0f },\n"
  "                                 { 0.0f, 0.0f } };\n"
  "\n"
  "        scalar = convert_float(y[0].x); yy[0] = (1.0f - t) * scalar;\n"
  "        scalar = convert_float(y[0].y); yy[1] = (1.0f - t) * scalar;\n"
  "        scalar = convert_float(y[0].z); yy[2] = (1.0f - t) * scalar;\n"
  "\n"
  "        scalar = convert_float(y[1].x); yy[0] = mad(t - s, scalar, yy[0]);\n"
  "        scalar = convert_float(y[1].y); yy[1] = mad(t - s, scalar, yy[1]);\n"
  "        scalar = convert_float(y[1].z); yy[2] = mad(t - s, scalar, yy[2]);\n"
  "\n"
  "        scalar = convert_float(y[2].x); yy[0] = mad(s,     scalar, yy[0]);\n"
  "        scalar = convert_float(y[2].y); yy[1] = mad(s,     scalar, yy[1]);\n"
  "        scalar = convert_float(y[2].z); yy[2] = mad(s,     scalar, yy[2]);\n"
  "\n"
  "        tmp    = vload2(q / 2, sq->wqs);\n"
  "\n"
  "        const float2 result = laplace3d2(xx, yy);\n"
  "\n"
  "\n"
  "\n"
  "        sum += convert_float(tmp.x) * result.x +\n"
  "               convert_float(tmp.y) * result.y;\n"
  "      }\n"
  "#else\n"
  "\n"
  "#endif\n"
  "      for(; q < sq->nq; ++q)\n"
  "      {\n"
  "        float s, t;\n"
  "\n"
  "#ifndef USE_FLOAT\n"
  "        t  = convert_float(sq->xqs[q]);\n"
  "        s  = convert_float(sq->xqs[q + sq->nq]);\n"
  "\n"
  "        private float3 xx, yy;\n"
  "\n"
  "        xx = (1.0f - t) * convert_float3(x[0]) +\n"
  "             (t - s)    * convert_float3(x[1]) +\n"
  "             s          * convert_float3(x[2]);\n"
  "\n"
  "        t  = convert_float(sq->yqs[q]);\n"
  "        s  = convert_float(sq->yqs[q + sq->nq]);\n"
  "\n"
  "        yy = (1.0f - t) * convert_float3(y[0]) +\n"
  "             (t - s)    * convert_float3(y[1]) +\n"
  "             s          * convert_float3(y[2]);\n"
  "#else\n"
  "        t  = sq->xqs[q];\n"
  "        s  = sq->xqs[q + sq->nq];\n"
  "\n"
  "        private float3 xx, yy;\n"
  "\n"
  "        xx = (r_one - t) * x[0] + (t - s) * x[1] + s * x[2];\n"
  "\n"
  "        t  = sq->yqs[q];\n"
  "        s  = sq->yqs[q + sq->nq];\n"
  "\n"
  "        yy = (r_one - t) * y[0] + (t - s) * y[1] + s * y[2];\n"
  "#endif\n"
  "\n"
  "        sum += sq->wqs[q] * laplace3d(xx, yy);\n"
  "      }\n"
  "\n"
  "      res += gcii->xt[j] * ((gc * gr * kernel_factor * sum) + factor);\n"
  "    }\n"
  "\n"
  "    for(uint j = 0; j < gcii->num_h2_leafs; ++j)\n"
  "    {\n"
  "      barrier(CLK_GLOBAL_MEM_FENCE);\n"
  "\n"
  "      if(get_local_id(0) == j)\n"
  "        gcii->yt[i] += alpha * res;\n"
  "    }\n"
  "  }\n"
  "}\n"
  "\n"
  "void\n"
  "mvm_on_the_fly_gca(pgcidxinfo gcii, pgeom sur, psingquadg sq,\n"
  "                   private const real bem_alpha,\n"
  "                   private const real kernel_factor,\n"
  "                   private const real alpha)\n"
  "{\n"
  "  const size_t lid0 = get_local_id(0);\n"
  "\n"
  "  for(uint i = 0; i < gcii->ridx_size; ++i)\n"
  "  {\n"
  "    const uint ii = gcii->ridx[i];\n"
  "\n"
  "    const real  gr = sur->g[ii];\n"
  "\n"
  "    const uint3 q  = vload3(ii, sur->p);\n"
  "\n"
  "    private real3 x[3];\n"
  "\n"
  "    x[0] = vload3(q.x, sur->v);\n"
  "    x[1] = vload3(q.y, sur->v);\n"
  "    x[2] = vload3(q.z, sur->v);\n"
  "\n"
  "    real res = r_zero;\n"
  "\n"
  "    for(uint j = 0; j < gcii->cidx_size; ++j)\n"
  "    {\n"
  "      const uint  jj = gcii->cidx[j];\n"
  "\n"
  "      const real  gc = sur->g[jj];\n"
  "      const uint3 p  = vload3(jj, sur->p);\n"
  "\n"
  "      const real factor = (ii == jj) * 0.5 * bem_alpha * gr;\n"
  "\n"
  "      private real3 y[3];\n"
  "\n"
  "      y[0] = vload3(p.x, sur->v);\n"
  "      y[1] = vload3(p.y, sur->v);\n"
  "      y[2] = vload3(p.z, sur->v);\n"
  "\n"
  "      real sum;\n"
  "      uint xp[3], yp[3];\n"
  "\n"
  "      global const real *xq, *yq, *wq;\n"
  "\n"
  "      select_quadratureg(sq, q, p, xp, yp, &xq, &yq, &wq, &sum);\n"
  "\n"
  "  //     for(uint k = 0; k < sq->nq; k += SIZE)\n"
  "  //     {\n"
  "  //       const size_t size = (k + SIZE) < sq->nq ? SIZE : sq->nq - k;\n"
  "  //\n"
  "  //       barrier(CLK_LOCAL_MEM_FENCE);\n"
  "  //\n"
  "  //       if(lid0 < size)\n"
  "  //       {\n"
  "  //         sq->xql[lid0]        = xq[k + lid0];\n"
  "  //         sq->xql[lid0 + SIZE] = xq[k + lid0 + sq->nq];\n"
  "  //         sq->yql[lid0]        = yq[k + lid0];\n"
  "  //         sq->yql[lid0 + SIZE] = yq[k + lid0 + sq->nq];\n"
  "  //         sq->wql[lid0]        = wq[k + lid0];\n"
  "  //       }\n"
  "  //\n"
  "  //       barrier(CLK_LOCAL_MEM_FENCE);\n"
  "  //\n"
  "  //       for(uint q = 0; q < size; ++q)\n"
  "  //       {\n"
  "  //         float s, t;\n"
  "  //\n"
  "  // #ifndef USE_FLOAT\n"
  "  //         t  = convert_float(sq->xql[q]);\n"
  "  //         s  = convert_float(sq->xql[q + SIZE]);\n"
  "  //\n"
  "  //         private float3 xx, yy;\n"
  "  //\n"
  "  //         xx = (1.0f - t) * convert_float3(x[xp[0]]) +\n"
  "  //              (t - s)    * convert_float3(x[xp[1]]) +\n"
  "  //              s          * convert_float3(x[xp[2]]);\n"
  "  //\n"
  "  //         t  = convert_float(sq->yql[q]);\n"
  "  //         s  = convert_float(sq->yql[q + SIZE]);\n"
  "  //\n"
  "  //         yy = (1.0f - t) * convert_float3(y[yp[0]]) +\n"
  "  //              (t - s)    * convert_float3(y[yp[1]]) +\n"
  "  //              s          * convert_float3(y[yp[2]]);\n"
  "  // #else\n"
  "  //         t  = xq1[q];\n"
  "  //         s  = xq2[q];\n"
  "  //\n"
  "  //         xx = (r_one - t) * x[xp[0]] + (t - s) * x[xp[1]] + s * x[xp[2]];\n"
  "  //\n"
  "  //         t  = yq1[q];\n"
  "  //         s  = yq2[q];\n"
  "  //\n"
  "  //         yy = (r_one - t) * y[yp[0]] + (t - s) * y[yp[1]] + s * y[yp[2]];\n"
  "  // #endif\n"
  "  //\n"
  "  //         sum += sq->wql[q] * laplace3d(xx, yy);\n"
  "  //       }\n"
  "  //     }\n"
  "\n"
  "      for(uint q = 0; q < sq->nq; ++q)\n"
  "      {\n"
  "        float s, t;\n"
  "\n"
  "#ifndef USE_FLOAT\n"
  "        t  = convert_float(xq[q]);\n"
  "        s  = convert_float(xq[q + sq->nq]);\n"
  "\n"
  "        private float3 xx, yy;\n"
  "\n"
  "        xx = (1.0f - t) * convert_float3(x[xp[0]]) +\n"
  "             (t - s)    * convert_float3(x[xp[1]]) +\n"
  "             s          * convert_float3(x[xp[2]]);\n"
  "\n"
  "        t  = convert_float(yq[q]);\n"
  "        s  = convert_float(yq[q + sq->nq]);\n"
  "\n"
  "        yy = (1.0f - t) * convert_float3(y[yp[0]]) +\n"
  "             (t - s)    * convert_float3(y[yp[1]]) +\n"
  "             s          * convert_float3(y[yp[2]]);\n"
  "#else\n"
  "        t  = xq[q];\n"
  "        s  = xq[q + sq->nq];\n"
  "\n"
  "        private float3 xx, yy;\n"
  "\n"
  "        xx = (r_one - t) * x[xp[0]] + (t - s) * x[xp[1]] + s * x[xp[2]];\n"
  "\n"
  "        t  = yq[q];\n"
  "        s  = yq[q + sq->nq];\n"
  "\n"
  "        yy = (r_one - t) * y[yp[0]] + (t - s) * y[yp[1]] + s * y[yp[2]];\n"
  "#endif\n"
  "\n"
  "        sum += wq[q] * laplace3d(xx, yy);\n"
  "      }\n"
  "\n"
  "      res += gcii->xt[j] * ((gc * gr * kernel_factor * sum) + factor);\n"
  "    }\n"
  "\n"
  "    for(uint j = 0; j < gcii->num_h2_leafs; ++j)\n"
  "    {\n"
  "      barrier(CLK_GLOBAL_MEM_FENCE);\n"
  "\n"
  "      if(get_local_id(0) == j)\n"
  "        gcii->yt[i] += alpha * res;\n"
  "    }\n"
  "  }\n"
  "}\n"
  "\n"
  "#endif // FASTADDEVAL_CL\n"
};

/** @} */

#endif // CLFASTADDEVALGCA_CL