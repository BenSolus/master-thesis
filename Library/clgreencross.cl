/* ------------------------------------------------------------
 * This is the file "clgreencross.cl" of this master thesis.
 * All rights reserved, Bennet Carstensen 2017
 * ------------------------------------------------------------ */

/**
 * @file      cl/clgreencross.cl
 * @author    Bennet Carstensen
 * @date      2017
 * @copyright All rights reserved, Bennet Carstensen 2017
 */

#ifndef CLGREENCROSS_CL
#define CLGREENCROSS_CL

/** @addtogroup greencross
 *  @{ */

/*  @brief The source code to performe operations on the module
 *         @ref greencross via OpenCL as a string. */
static const char clgreencross_src[] =
{
  "#ifndef GREENCROSS_CL\n"
  "#define GREENCROSS_CL\n"
  "\n"
  "\n"
  "#ifdef USE_FLOAT\n"
  "typedef float4  real4;\n"
  "typedef float8  real8;\n"
  "typedef float16 real16;\n"
  "#else\n"
  "typedef double4  real4;\n"
  "typedef double8  real8;\n"
  "typedef double16 real16;\n"
  "#endif\n"
  "\n"
  "constant static real r_four_pi = 0.0795774715459476;\n"
  "\n"
  "real\n"
  "laplace3d(private float3 x, private float3 y)\n"
  "{\n"
  "  private float3 xmy2 = x - y;\n"
  "  xmy2 *= xmy2;\n"
  "\n"
  "\n"
  "  const float norm2 = xmy2.x + xmy2.y + xmy2.z;\n"
  "\n"
  "  float norm;\n"
  "\n"
  "  norm = native_rsqrt(norm2);\n"
  "\n"
  "  return r_four_pi * norm;\n"
  "}\n"
  "\n"
  "// kernel void\n"
  "// fastaddeval_h2matrix_avector_1(       const uint dim,\n"
  "//                                       const uint n,\n"
  "//                                global const real *vs,\n"
  "//                                global const uint *p,\n"
  "//                                global const real *g,\n"
  "//                                       const uint nq,\n"
  "//                                constant     real *qx,\n"
  "//                                constant     real *qy,\n"
  "//                                constant     real *w,\n"
  "//                                       const uint num_row_leafs,\n"
  "//                                global const uint *rows_this_device,\n"
  "//                                global const uint *num_h2_leafs_per_cluster,\n"
  "//                                global const uint *idx_offs,\n"
  "//                                global const uint *ridx_sizes,\n"
  "//                                global const uint *cidx_sizes,\n"
  "//                                global const uint *ridx_offs,\n"
  "//                                global const uint *cidx_offs,\n"
  "//                                global const uint *ridxs,\n"
  "//                                global const uint *cidxs,\n"
  "//                                       const real alpha,\n"
  "//                                global const uint *xt_offs,\n"
  "//                                global const uint *yt_offs,\n"
  "//                                global const real *xts,\n"
  "//                                global       real *yt)\n"
  "// {\n"
  "//   const size_t grpid0 = get_group_id(0);\n"
  "//\n"
  "//   if(grpid0 >= num_row_leafs)\n"
  "//     return;\n"
  "//   else\n"
  "//   {\n"
  "//     const uint   row_this_group = rows_this_device[grpid0];\n"
  "//\n"
  "//     const uint   num_h2_leafs   = num_h2_leafs_per_cluster[row_this_group];\n"
  "//     const size_t lid0           = get_local_id(0);\n"
  "//\n"
  "//     gcidxinfo gcii;\n"
  "//     geom      sur;\n"
  "//     quad      quad;\n"
  "//\n"
  "//     local   real  yt_tmp[32], gr_tmp[32];\n"
  "//     local   real3 x_tmp[32][3];\n"
  "//     private real  gc0, gc1;\n"
  "//     private real  *gc;\n"
  "//     private real3 (*y)[3];\n"
  "//     private real3 x[3], y0[3], y1[3], xx, yy;\n"
  "//\n"
  "//     uint    k = 0;\n"
  "//\n"
  "//     init_geom(&sur, dim, n, vs, p, g, 0, 0);\n"
  "//     init_quad(&quad, nq, qx, qy, w);\n"
  "//\n"
  "//     /* Same information for all threads in a work group */\n"
  "//     init_row_gcidxinfo(&gcii,\n"
  "//                        num_h2_leafs,\n"
  "//                        idx_offs[row_this_group],\n"
  "//                        ridx_sizes[row_this_group],\n"
  "//                        ridx_offs[row_this_group],\n"
  "//                        ridxs,\n"
  "//                        yt_offs[row_this_group],\n"
  "//                        yt,\n"
  "//                        0);\n"
  "//\n"
  "//     /* Different information for all threads in a work group */\n"
  "//     if(lid0 < num_h2_leafs)\n"
  "//       set_column_info_gcidxinfo(&gcii,\n"
  "//                                 cidx_sizes[gcii.idx_off + lid0],\n"
  "//                                 cidx_offs[gcii.idx_off + lid0],\n"
  "//                                 cidxs,\n"
  "//                                 xt_offs[gcii.idx_off + lid0],\n"
  "//                                 xts);\n"
  "//\n"
  "//     //if(32 < gcii.ridx_size : 32 : gcii.ridx_size)\n"
  "//     for(k = 0; k < gcii.ridx_size; k += 32)\n"
  "//     {\n"
  "//       const uint loops = (k + 32) < gcii.ridx_size ? 32 : gcii.ridx_size - k;\n"
  "//\n"
  "//       barrier(CLK_LOCAL_MEM_FENCE);\n"
  "//\n"
  "//       if(lid0 < loops)\n"
  "//       {\n"
  "//         const uint  ii = gcii.ridx[k + lid0];\n"
  "//\n"
  "//         gr_tmp[lid0]   = sur.g[ii];\n"
  "//\n"
  "//         const uint3 p  = vload3(ii, sur.p);\n"
  "//\n"
  "//         x_tmp[lid0][0] = vload3(p.x, sur.v);\n"
  "//         x_tmp[lid0][1] = vload3(p.y, sur.v);\n"
  "//         x_tmp[lid0][2] = vload3(p.z, sur.v);\n"
  "//\n"
  "//         yt_tmp[lid0]   = r_zero;\n"
  "//       }\n"
  "//\n"
  "//       if(lid0 < num_h2_leafs)\n"
  "//       {\n"
  "//         for(uint i = 0; i < loops; ++i)\n"
  "//         {\n"
  "//           barrier(CLK_LOCAL_MEM_FENCE);\n"
  "//\n"
  "//           const uint ii = (lid0 + i) % loops;\n"
  "//           const real gr = gr_tmp[ii];\n"
  "//\n"
  "//           x[0] = x_tmp[ii][0];\n"
  "//           x[1] = x_tmp[ii][1];\n"
  "//           x[2] = x_tmp[ii][2];\n"
  "//\n"
  "//           real res = r_zero;\n"
  "//\n"
  "//           uint  jj = gcii.cidx[0];\n"
  "//           uint3 p  = vload3(jj, sur.p);\n"
  "//\n"
  "//           gc0 = sur.g[jj];\n"
  "//\n"
  "//           y0[0] = vload3(p.x, sur.v);\n"
  "//           y0[1] = vload3(p.y, sur.v);\n"
  "//           y0[2] = vload3(p.z, sur.v);\n"
  "//\n"
  "//           uchar prefetch_switch = 1;\n"
  "//\n"
  "//           for(uint j = 0; j < gcii.cidx_size; ++j)\n"
  "//           {\n"
  "//             if(j < (gcii.cidx_size - 1))\n"
  "//             {\n"
  "//               gc  = prefetch_switch == 0 ? &gc0 : &gc1;\n"
  "//               y   = prefetch_switch == 0 ? &y0 : &y1;\n"
  "//\n"
  "//               jj  = gcii.cidx[j + 1];\n"
  "//\n"
  "//               *gc = sur.g[jj];\n"
  "//\n"
  "//               *y[0] = vload3(p.x, sur.v);\n"
  "//               *y[1] = vload3(p.y, sur.v);\n"
  "//               *y[2] = vload3(p.z, sur.v);\n"
  "//\n"
  "//               prefetch_switch = prefetch_switch == 0 ? 1 : 0;\n"
  "//             }\n"
  "//\n"
  "//             gc  = prefetch_switch == 0 ? &gc0 : &gc1;\n"
  "//             y   = prefetch_switch == 0 ? &y0 : &y1;\n"
  "//\n"
  "//             real sum = r_zero;\n"
  "//\n"
  "//             for(uint q = 0; q < quad.nq; ++q)\n"
  "//             {\n"
  "//               real t = quad.qx[q];\n"
  "//               real s = quad.qx[q + quad.nq];\n"
  "//\n"
  "//               xx = (r_one - t) * x[0] + (t - s) * x[1] + s * x[2];\n"
  "//\n"
  "//               t = quad.qy[q];\n"
  "//               s = quad.qy[q + quad.nq];\n"
  "//\n"
  "//               yy = (r_one - t) * *y[0] + (t - s) * *y[1] + s * *y[2];\n"
  "//\n"
  "//               sum += quad.w[q] * laplace3d((float3) xx, (float3) yy);\n"
  "//             }\n"
  "//\n"
  "//             res += gcii.xt[j] * *gc * gr * sum;\n"
  "//           }\n"
  "//\n"
  "//           for(uint j = 0; j < num_h2_leafs; j += loops)\n"
  "//           {\n"
  "//             const uint max = (j + loops) < num_h2_leafs\n"
  "//                                ? j + loops\n"
  "//                                : num_h2_leafs;\n"
  "//\n"
  "//\n"
  "//             barrier(CLK_LOCAL_MEM_FENCE);\n"
  "//\n"
  "//             if((lid0 >= j) && (lid0 < max))\n"
  "//               yt_tmp[ii] += res;\n"
  "//           }\n"
  "//         }\n"
  "//       }\n"
  "//\n"
  "//       barrier(CLK_LOCAL_MEM_FENCE);\n"
  "//\n"
  "//       if(lid0 < loops)\n"
  "//         gcii.yt[k + lid0] = alpha * yt_tmp[lid0];\n"
  "//     }\n"
  "//   }\n"
  "// }\n"
  "\n"
  "kernel void\n"
  "fastaddeval_h2matrix_avector_0(       const uint dim,\n"
  "                                      const uint n,\n"
  "                               global const real *vs,\n"
  "                               global const uint *p,\n"
  "                               global const real *g,\n"
  "                                      const uint nq,\n"
  "                               constant     real *qx,\n"
  "                               constant     real *qy,\n"
  "                               constant     real *w,\n"
  "                                      const uint num_row_leafs,\n"
  "                               global const uint *rows_this_device,\n"
  "                               global const uint *num_h2_leafs_per_cluster,\n"
  "                               global const uint *idx_offs,\n"
  "                               global const uint *ridx_sizes,\n"
  "                               global const uint *cidx_sizes,\n"
  "                               global const uint *ridx_offs,\n"
  "                               global const uint *cidx_offs,\n"
  "                               global const uint *ridxs,\n"
  "                               global const uint *cidxs,\n"
  "                                      const real alpha,\n"
  "                               global const uint *xt_offs,\n"
  "                               global const uint *yt_offs,\n"
  "                               global const real *xts,\n"
  "                               global       real *yt)\n"
  "{\n"
  "  const size_t grpid0 = get_group_id(0);\n"
  "\n"
  "  if(grpid0 >= num_row_leafs)\n"
  "    return;\n"
  "  else\n"
  "  {\n"
  "    const uint   row_this_group = rows_this_device[grpid0];\n"
  "\n"
  "    const uint   num_h2_leafs   = num_h2_leafs_per_cluster[row_this_group];\n"
  "    const size_t lid0           = get_local_id(0);\n"
  "\n"
  "\n"
  "    gcidxinfo gcii;\n"
  "    geom      sur;\n"
  "    quad      quad;\n"
  "\n"
  "    local   real  yt_tmp[32], gr_tmp[32];\n"
  "    local   real3 x_tmp[32][3];\n"
  "    private float3 xx, yy;\n"
  "    private real3 x[3], y[3];\n"
  "\n"
  "    init_geom(&sur, dim, n, vs, p, g, 0, 0);\n"
  "    init_quad(&quad, nq, qx, qy, w);\n"
  "\n"
  "    /* Same information for all threads in a work group */\n"
  "    init_row_gcidxinfo(&gcii,\n"
  "                       num_h2_leafs,\n"
  "                       idx_offs[row_this_group],\n"
  "                       ridx_sizes[row_this_group],\n"
  "                       ridx_offs[row_this_group],\n"
  "                       ridxs,\n"
  "                       yt_offs[row_this_group],\n"
  "                       yt,\n"
  "                       0);\n"
  "\n"
  "    /* Different information for all threads in a work group */\n"
  "    if(lid0 < num_h2_leafs)\n"
  "      set_column_info_gcidxinfo(&gcii,\n"
  "                                cidx_sizes[gcii.idx_off + lid0],\n"
  "                                cidx_offs[gcii.idx_off + lid0],\n"
  "                                cidxs,\n"
  "                                xt_offs[gcii.idx_off + lid0],\n"
  "                                xts);\n"
  "\n"
  "    for(uint k = 0; k < gcii.ridx_size; k += 32)\n"
  "    {\n"
  "      const uint loops = (k + 32) < gcii.ridx_size ? 32 : gcii.ridx_size - k;\n"
  "\n"
  "      barrier(CLK_LOCAL_MEM_FENCE);\n"
  "\n"
  "      if(lid0 < loops)\n"
  "      {\n"
  "        const uint  ii = gcii.ridx[k + lid0];\n"
  "\n"
  "        gr_tmp[lid0]   = sur.g[ii];\n"
  "\n"
  "        const uint3 p  = vload3(ii, sur.p);\n"
  "\n"
  "        x_tmp[lid0][0] = vload3(p.x, sur.v);\n"
  "        x_tmp[lid0][1] = vload3(p.y, sur.v);\n"
  "        x_tmp[lid0][2] = vload3(p.z, sur.v);\n"
  "\n"
  "        yt_tmp[lid0]   = r_zero;\n"
  "      }\n"
  "\n"
  "      if(lid0 < num_h2_leafs)\n"
  "      {\n"
  "        for(uint i = 0; i < loops; ++i)\n"
  "        {\n"
  "          barrier(CLK_LOCAL_MEM_FENCE);\n"
  "\n"
  "          const uint ii = (lid0 + i) % loops;\n"
  "          const real gr = gr_tmp[ii];\n"
  "\n"
  "          x[0] = x_tmp[ii][0];\n"
  "          x[1] = x_tmp[ii][1];\n"
  "          x[2] = x_tmp[ii][2];\n"
  "\n"
  "          real res = r_zero;\n"
  "\n"
  "          for(uint j = 0; j < gcii.cidx_size; ++j)\n"
  "          {\n"
  "            const uint jj = gcii.cidx[j];\n"
  "            const real gc = sur.g[jj];\n"
  "\n"
  "            private uint3 p = vload3(jj, sur.p);\n"
  "\n"
  "            y[0] = vload3(p.x, sur.v);\n"
  "            y[1] = vload3(p.y, sur.v);\n"
  "            y[2] = vload3(p.z, sur.v);\n"
  "\n"
  "            real sum = r_zero;\n"
  "\n"
  "            for(uint q = 0; q < quad.nq; ++q)\n"
  "            {\n"
  "              float s, t;\n"
  "\n"
  "#ifndef USE_FLOAT\n"
  "              t  = convert_float(quad.qx[q]);\n"
  "              s  = convert_float(quad.qx[q + quad.nq]);\n"
  "\n"
  "              xx = (1.0f - t) * convert_float3(x[0]) +\n"
  "                   (t - s)    * convert_float3(x[1]) +\n"
  "                   s          * convert_float3(x[2]);\n"
  "\n"
  "              t  = convert_float(quad.qy[q]);\n"
  "              s  = convert_float(quad.qy[q + quad.nq]);\n"
  "\n"
  "              yy = (1.0f - t) * convert_float3(y[0]) +\n"
  "                   (t - s)    * convert_float3(y[1]) +\n"
  "                   s          * convert_float3(y[2]);\n"
  "#else\n"
  "              t  = quad.qx[q];\n"
  "              s  = quad.qx[q + quad.nq]\n"
  "\n"
  "              xx = (r_one - t) * x[0] + (t - s) * x[1] + s * x[2];\n"
  "\n"
  "              t = quad.qy[q];\n"
  "              s = quad.qy[q + quad.nq];\n"
  "\n"
  "              yy = (r_one - t) * y[0] + (t - s) * y[1] + s * y[2];\n"
  "#endif\n"
  "\n"
  "              sum += quad.w[q] * laplace3d(xx, yy);\n"
  "            }\n"
  "\n"
  "            res += gcii.xt[j] * gc * gr * sum;\n"
  "          }\n"
  "\n"
  "          for(uint j = 0; j < num_h2_leafs; j += loops)\n"
  "          {\n"
  "            const uint max = (j + loops) < num_h2_leafs\n"
  "                               ? j + loops\n"
  "                               : num_h2_leafs;\n"
  "\n"
  "\n"
  "            barrier(CLK_LOCAL_MEM_FENCE);\n"
  "\n"
  "            if((lid0 >= j) && (lid0 < max))\n"
  "              yt_tmp[ii] += res;\n"
  "          }\n"
  "        }\n"
  "      }\n"
  "\n"
  "      barrier(CLK_LOCAL_MEM_FENCE);\n"
  "\n"
  "      if(lid0 < loops)\n"
  "        gcii.yt[k + lid0] = alpha * yt_tmp[lid0];\n"
  "    }\n"
  "  }\n"
  "}\n"
  "\n"
  "#endif\n"
};

/** @} */

#endif // CLGREENCROSS_CL