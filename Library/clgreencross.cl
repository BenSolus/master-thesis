/* ------------------------------------------------------------
 * This is the file "clgreencross.cl" of this master thesis.
 * All rights reserved, Steffen Boerm 2009
 * ------------------------------------------------------------ */

/**
 * @file      cl/clgreencross.cl
 * @author    Bennet Carstensen
 * @date      2017
 * @copyright All rights reserved, Bennet Carstensen 2017
 */

#ifndef CLGREENCROSS_CL
#define CLGREENCROSS_CL

/** @addtogroup greencross
 *  @{ */

/*  @brief The source code to performe operations on the module
 *         @ref greencross via OpenCL as a string. */
static const char clgreencross_src[] =
{
  "#ifndef GREENCROSS_CL\n"
  "#define GREENCROSS_CL\n"
  "\n"
  "\n"
  "#ifdef USE_FLOAT\n"
  "typedef float2  real2;\n"
  "typedef float4  real4;\n"
  "typedef float8  real8;\n"
  "typedef float16 real16;\n"
  "#else\n"
  "typedef double2  real2;\n"
  "typedef double4  real4;\n"
  "typedef double8  real8;\n"
  "typedef double16 real16;\n"
  "#endif\n"
  "\n"
  "constant static real r_four_pi = 0.0795774715459476;\n"
  "\n"
  "real\n"
  "laplace3d(private real *x, private real *y)\n"
  "{\n"
  "  real norm;\n"
  "\n"
  "  const real norm2 = (x[0] - y[0]) * (x[0] - y[0]) +\n"
  "                     (x[1] - y[1]) * (x[1] - y[1]) +\n"
  "                     (x[2] - y[2]) * (x[2] - y[2]);\n"
  "\n"
  "#ifndef USE_FLOAT\n"
  "  norm = convert_double(native_rsqrt(convert_float(norm2)));\n"
  "#else\n"
  "  norm = native_rsqrt(norm2);\n"
  "#endif\n"
  "\n"
  "  return r_four_pi * norm;\n"
  "}\n"
  "\n"
  "void\n"
  "mvm_sub_row(pgeom      sur,\n"
  "            pquad      quad,\n"
  "            pgcidxinfo gcii,\n"
  "                    const uint i,\n"
  "            global  const uint *cidx_sizes,\n"
  "            global  const uint *cidx_offs,\n"
  "            global  const uint *cidxs,\n"
  "            global  const uint *xt_offs,\n"
  "            global  const real *xts,\n"
  "            private       real x[3][3],\n"
  "            private       real y[3][3],\n"
  "            private       real xx[3],\n"
  "            private       real yy[3])\n"
  "{\n"
  "  const size_t lid0    = get_local_id(0);\n"
  "  const size_t lsize0  = get_local_size(0);\n"
  "\n"
  "  real gr;\n"
  "\n"
  "  if((i + lid0) < gcii->ridx_size)\n"
  "  {\n"
  "    const uint ii = gcii->ridx[i + lid0];\n"
  "    gr = sur->g[ii];\n"
  "\n"
  "    for(uint d1 = 0; d1 < sur->dim; ++d1)\n"
  "      for(uint d2 = 0; d2 < sur->dim; ++d2)\n"
  "        x[d1][d2] = sur->v[d2 + sur->dim * sur->p[sur->dim * ii + d1]];\n"
  "  }\n"
  "\n"
  "  real res = r_zero;\n"
  "\n"
  "  for(uint k = 0; k < gcii->num_h2_leafs; ++k)\n"
  "  {\n"
  "    set_column_info_gcidxinfo(gcii,\n"
  "                              cidx_sizes[gcii->idx_off + k],\n"
  "                              cidx_offs[gcii->idx_off + k],\n"
  "                              cidxs,\n"
  "                              xt_offs[gcii->idx_off + k],\n"
  "                              xts);\n"
  "\n"
  "    for(uint j = 0; j < gcii->cidx_size; ++j)\n"
  "    {\n"
  "      const uint jj = gcii->cidx[j]; // Bank conflict\n"
  "      const real gc = sur->g[jj];\n"
  "\n"
  "      for(uint d1 = 0; d1 < sur->dim; ++d1)\n"
  "        for(uint d2 = 0; d2 < sur->dim; ++d2)\n"
  "          y[d1][d2] = sur->v[d2 + sur->dim * sur->p[sur->dim * jj + d1]];\n"
  "\n"
  "      if((i + lid0) < gcii->ridx_size)\n"
  "      {\n"
  "        real sum = r_zero;\n"
  "\n"
  "        for(uint q = 0; q < quad->nq; ++q)\n"
  "        {\n"
  "          real t = quad->qx[q];\n"
  "          real s = quad->qx[q + quad->nq];\n"
  "\n"
  "          xx[0] = (r_one - t) * x[0][0] + (t - s) * x[1][0] + s * x[2][0];\n"
  "          xx[1] = (r_one - t) * x[0][1] + (t - s) * x[1][1] + s * x[2][1];\n"
  "          xx[2] = (r_one - t) * x[0][2] + (t - s) * x[1][2] + s * x[2][2];\n"
  "\n"
  "          t = quad->qy[q];\n"
  "          s = quad->qy[q + quad->nq];\n"
  "\n"
  "          yy[0] = (r_one - t) * y[0][0] + (t - s) * y[1][0] + s * y[2][0];\n"
  "          yy[1] = (r_one - t) * y[0][1] + (t - s) * y[1][1] + s * y[2][1];\n"
  "          yy[2] = (r_one - t) * y[0][2] + (t - s) * y[1][2] + s * y[2][2];\n"
  "\n"
  "          sum += quad->w[q] * laplace3d(xx, yy);\n"
  "        }\n"
  "\n"
  "        res += gcii->xt[j] * gc * gr * sum;\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "\n"
  "  if((i + lid0) < gcii->ridx_size)\n"
  "    gcii->yt[i + lid0] += res;\n"
  "}\n"
  "\n"
  "kernel void\n"
  "fastaddeval_h2matrix_avector(       const uint dim,\n"
  "                                    const uint n,\n"
  "                             global const real *vs,\n"
  "                             global const uint *p,\n"
  "                             global const real *g,\n"
  "                                    const uint nq,\n"
  "                             constant     real *qx,\n"
  "                             constant     real *qy,\n"
  "                             constant     real *w,\n"
  "                                    const uint num_row_leafs,\n"
  "                             global const uint *num_h2_leafs_per_cluster,\n"
  "                             global const uint *idx_offs,\n"
  "                             global const uint *ridx_sizes,\n"
  "                             global const uint *cidx_sizes,\n"
  "                             global const uint *ridx_offs,\n"
  "                             global const uint *cidx_offs,\n"
  "                             global const uint *ridxs,\n"
  "                             global const uint *cidxs,\n"
  "                                    const real alpha,\n"
  "                             global const uint *xt_offs,\n"
  "                             global const uint *yt_offs,\n"
  "                             global const real *xts,\n"
  "                             global       real *yt)\n"
  "{\n"
  "  const size_t grpid0 = get_group_id(0);\n"
  "\n"
  "  if(grpid0 >= num_row_leafs)\n"
  "    return;\n"
  "  else\n"
  "  {\n"
  "    local real xt_tmp[WRK_GRP_SIZE0];\n"
  "    local uint cidx_tmp[WRK_GRP_SIZE0];\n"
  "\n"
  "    pgeom sur  = new_geom(dim, n, vs, p, g);\n"
  "    pquad quad = new_quad(nq, qx, qy, w);\n"
  "    pgcidxinfo gcii = new_row_gcidxinfo(num_h2_leafs_per_cluster[grpid0],\n"
  "                                        idx_offs[grpid0],\n"
  "                                        ridx_sizes[grpid0],\n"
  "                                        ridx_offs[grpid0],\n"
  "                                        ridxs,\n"
  "                                        yt_offs[grpid0],\n"
  "                                        yt,\n"
  "                                        cidx_tmp,\n"
  "                                        xt_tmp);\n"
  "\n"
  "    const size_t lid0    = get_local_id(0);\n"
  "    const size_t lsize0  = get_local_size(0);\n"
  "\n"
  "    private real x[3][3], y[3][3], xx[3], yy[3];\n"
  "\n"
  "    uint i = 0;\n"
  "\n"
  "    for(i = 0; (i + lsize0) < gcii->ridx_size; i += lsize0)\n"
  "      mvm_sub_row(sur,\n"
  "                  quad,\n"
  "                  gcii,\n"
  "                  i,\n"
  "                  cidx_sizes,\n"
  "                  cidx_offs,\n"
  "                  cidxs,\n"
  "                  xt_offs,\n"
  "                  xts,\n"
  "                  x,\n"
  "                  y,\n"
  "                  xx,\n"
  "                  yy);\n"
  "    // {\n"
  "    //   const uint ii = gcii->ridx[i + lid0];\n"
  "    //   const real gr = sur->g[ii];\n"
  "    //\n"
  "    //   for(uint d1 = 0; d1 < dim; ++d1)\n"
  "    //     for(uint d2 = 0; d2 < dim; ++d2)\n"
  "    //       x[d1][d2] = sur->v[d2 + dim * p[dim * ii + d1]];\n"
  "    //\n"
  "    //   real res = r_zero;\n"
  "    //\n"
  "    //   for(uint k = 0; k < gcii->num_h2_leafs; ++k)\n"
  "    //   {\n"
  "    //     set_column_info_gcidxinfo(gcii,\n"
  "    //                               cidx_sizes[gcii->idx_off + k],\n"
  "    //                               cidx_offs[gcii->idx_off + k],\n"
  "    //                               cidxs,\n"
  "    //                               xt_offs[gcii->idx_off + k],\n"
  "    //                               xt);\n"
  "    //\n"
  "    //     // const uint cidx_size = cidx_sizes[gcii->idx_off + k];\n"
  "    //     // const uint cidx_off  = cidx_offs[gcii->idx_off + k];\n"
  "    //     // const uint xt_off    = xt_offs[gcii->idx_off + k];\n"
  "    //\n"
  "    //     for(uint j = 0; j < gcii->cidx_size; ++j)\n"
  "    //     {\n"
  "    //       const uint jj = gcii->cidx[j]; // Bank conflict\n"
  "    //       const real gc = sur->g[jj];\n"
  "    //\n"
  "    //       for(uint d1 = 0; d1 < dim; ++d1)\n"
  "    //         for(uint d2 = 0; d2 < dim; ++d2)\n"
  "    //           y[d1][d2] = sur->v[d2 + dim * p[dim * jj + d1]];\n"
  "    //\n"
  "    //       real sum = r_zero;\n"
  "    //\n"
  "    //       for(uint q = 0; q < quad->nq; ++q)\n"
  "    //       {\n"
  "    //         real t = quad->qx[q];\n"
  "    //         real s = quad->qx[q + nq];\n"
  "    //\n"
  "    //         xx[0] = (r_one - t) * x[0][0] + (t - s) * x[1][0] + s * x[2][0];\n"
  "    //         xx[1] = (r_one - t) * x[0][1] + (t - s) * x[1][1] + s * x[2][1];\n"
  "    //         xx[2] = (r_one - t) * x[0][2] + (t - s) * x[1][2] + s * x[2][2];\n"
  "    //\n"
  "    //         t = quad->qy[q];\n"
  "    //         s = quad->qy[q + nq];\n"
  "    //\n"
  "    //         yy[0] = (r_one - t) * y[0][0] + (t - s) * y[1][0] + s * y[2][0];\n"
  "    //         yy[1] = (r_one - t) * y[0][1] + (t - s) * y[1][1] + s * y[2][1];\n"
  "    //         yy[2] = (r_one - t) * y[0][2] + (t - s) * y[1][2] + s * y[2][2];\n"
  "    //\n"
  "    //         sum += quad->w[q] * laplace3d(xx, yy);\n"
  "    //       }\n"
  "    //\n"
  "    //       // res += xt[xt_off + j] * gc * gr * sum;\n"
  "    //       res += gcii->xt[j] * gc * gr * sum;\n"
  "    //     }\n"
  "    //   }\n"
  "    //\n"
  "    //   gcii->yt[i + lid0] += res;\n"
  "    // }\n"
  "\n"
  "    mvm_sub_row(sur,\n"
  "                quad,\n"
  "                gcii,\n"
  "                i,\n"
  "                cidx_sizes,\n"
  "                cidx_offs,\n"
  "                cidxs,\n"
  "                xt_offs,\n"
  "                xts,\n"
  "                x,\n"
  "                y,\n"
  "                xx,\n"
  "                yy);\n"
  "  //   {\n"
  "  //     const uint ii = gcii->ridx[i + lid0];\n"
  "  //     const real gr = g[ii];\n"
  "  //\n"
  "  //     for(uint d1 = 0; d1 < dim; ++d1)\n"
  "  //       for(uint d2 = 0; d2 < dim; ++d2)\n"
  "  //         x[d1][d2] = vs[d2 + dim * p[dim * ii + d1]];\n"
  "  //\n"
  "  //     real res = r_zero;\n"
  "  //\n"
  "  //     for(uint k = 0; k < gcii->num_h2_leafs; ++k)\n"
  "  //     {\n"
  "  //       set_column_info_gcidxinfo(gcii,\n"
  "  //                                 cidx_sizes[gcii->idx_off + k],\n"
  "  //                                 cidx_offs[gcii->idx_off + k],\n"
  "  //                                 cidxs,\n"
  "  //                                 xt_offs[gcii->idx_off + k],\n"
  "  //                                 xts);\n"
  "  //\n"
  "  //       // const uint cidx_size = cidx_sizes[gcii->idx_off + k];\n"
  "  //       // const uint cidx_off  = cidx_offs[gcii->idx_off + k];\n"
  "  //       // const uint xt_off    = xt_offs[gcii->idx_off + k];\n"
  "  //\n"
  "  //       for(uint j = 0; j < gcii->cidx_size; ++j)\n"
  "  //       {\n"
  "  //         const uint jj = gcii->cidx[j]; // Bank conflict\n"
  "  //         const real gc = g[jj];\n"
  "  //\n"
  "  //         for(uint d1 = 0; d1 < dim; ++d1)\n"
  "  //           for(uint d2 = 0; d2 < dim; ++d2)\n"
  "  //             y[d1][d2] = vs[d2 + dim * p[dim * jj + d1]];\n"
  "  //\n"
  "  //         real sum = r_zero;\n"
  "  //\n"
  "  //         for(uint q = 0; q < nq; ++q)\n"
  "  //         {\n"
  "  //           real t = qx[q];\n"
  "  //           real s = qx[q + nq];\n"
  "  //\n"
  "  //           xx[0] = (r_one - t) * x[0][0] + (t - s) * x[1][0] + s * x[2][0];\n"
  "  //           xx[1] = (r_one - t) * x[0][1] + (t - s) * x[1][1] + s * x[2][1];\n"
  "  //           xx[2] = (r_one - t) * x[0][2] + (t - s) * x[1][2] + s * x[2][2];\n"
  "  //\n"
  "  //           t = qy[q];\n"
  "  //           s = qy[q + nq];\n"
  "  //\n"
  "  //           yy[0] = (r_one - t) * y[0][0] + (t - s) * y[1][0] + s * y[2][0];\n"
  "  //           yy[1] = (r_one - t) * y[0][1] + (t - s) * y[1][1] + s * y[2][1];\n"
  "  //           yy[2] = (r_one - t) * y[0][2] + (t - s) * y[1][2] + s * y[2][2];\n"
  "  //\n"
  "  //           sum += w[q] * laplace3d(xx, yy);\n"
  "  //         }\n"
  "  //\n"
  "  //         res += gcii->xt[j] * gc * gr * sum;\n"
  "  //       }\n"
  "  //     }\n"
  "  //\n"
  "  //     gcii->yt[i + lid0] += res;\n"
  "  //   }\n"
  "  }\n"
  "}\n"
  "\n"
  "#endif\n"
};

/** @} */

#endif // CLGREENCROSS_CL