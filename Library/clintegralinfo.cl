/* ------------------------------------------------------------
 * This is the file "clintegralinfo.cl" of this master thesis.
 * All rights reserved, Bennet Carstensen 2017
 * ------------------------------------------------------------ */

/**
 * @file      cl/clintegralinfo.cl
 * @author    Bennet Carstensen
 * @date      2017
 * @copyright All rights reserved, Bennet Carstensen 2017
 */

#ifndef CLINTEGRALINFO_CL
#define CLINTEGRALINFO_CL

/** @addtogroup integralinfo
 *  @{ */

/*  @brief The source code to performe operations on the module
 *         @ref integralinfo via OpenCL as a string. */
static const char clintegralinfo_src[] =
{
  "#ifndef INTEGRALINFO_CL\n"
  "#define INTEGRALINFO_CL\n"
  "\n"
  "\n"
  "typedef struct _intinfo intinfo;\n"
  "\n"
  "typedef intinfo *pintinfo;\n"
  "\n"
  "typedef const intinfo *pcintinfo;\n"
  "\n"
  "struct _intinfo\n"
  "{\n"
  "  uint num_integrals;\n"
  "\n"
  "  global const uint *rows;\n"
  "\n"
  "  global const uint *cols;\n"
  "\n"
  "  global const uint *cidx;\n"
  "};\n"
  "\n"
  "void\n"
  "init_intinfo(             pintinfo iinfo,\n"
  "                    const uint     num_integrals,\n"
  "                    const uint     idx_off,\n"
  "             global const uint     *rows,\n"
  "             global const uint     *cols,\n"
  "             global const uint     *cidxs)\n"
  "{\n"
  "  iinfo->num_integrals = num_integrals;\n"
  "  iinfo->rows          = rows  + idx_off;\n"
  "  iinfo->cols          = cols  + idx_off;\n"
  "  iinfo->cidx          = cidxs + idx_off;\n"
  "}\n"
  "\n"
  "void\n"
  "eval_integrals(pgcidxinfo gcii, pcintinfo iinfo, pcgeom sur, psingquadc sq,\n"
  "               private const real bem_alpha,\n"
  "               private const real kernel_factor,\n"
  "               private const real alpha,\n"
  "               global  const real *xts)\n"
  "{\n"
  "  const size_t lid0 = get_local_id(0);\n"
  "\n"
  "  for(uint k = 0; k < iinfo->num_integrals; ++k)\n"
  "  {\n"
  "    const uint i  = iinfo->rows[k];\n"
  "    const uint j  = iinfo->cols[k];\n"
  "\n"
  "    const uint ii = gcii->ridx[i];\n"
  "    const uint jj = iinfo->cidx[k];\n"
  "\n"
  "    const real gr     = sur->g[ii];\n"
  "\n"
  "    const real factor = gr * sur->g[jj] * kernel_factor;\n"
  "\n"
  "    const uint3 p = vload3(ii, sur->p);\n"
  "    const uint3 q = vload3(jj, sur->p);\n"
  "\n"
  "    private const real3 x[3] = { vload3(p.x, sur->v),\n"
  "                                 vload3(p.y, sur->v),\n"
  "                                 vload3(p.z, sur->v) };\n"
  "\n"
  "    private const real3 y[3] = { vload3(q.x, sur->v),\n"
  "                                 vload3(q.y, sur->v),\n"
  "                                 vload3(q.z, sur->v) };\n"
  "\n"
  "    real base;\n"
  "    uint nq;\n"
  "    uint xp[3], yp[3];\n"
  "\n"
  "    constant real *xq, *yq, *wq;\n"
  "\n"
  "    select_uncommon_quadraturec(sq, p, q, xp, yp, &nq, &xq, &yq, &wq, &base);\n"
  "\n"
  "\n"
  "    // uint test = (p.x == q.x) + (p.x == q.y) + (p.x == q.z) +\n"
  "    //             (p.y == q.x) + (p.y == q.y) + (p.y == q.z) +\n"
  "    //             (p.z == q.x) + (p.z == q.y) + (p.z == q.z);\n"
  "    //\n"
  "    // if(get_global_id(0) == 0 && k == 0) printf(\"%u\\n\", test);\n"
  "\n"
  "    real sum = r_zero;\n"
  "\n"
  "    gcii->ytl[0] = r_zero;\n"
  "\n"
  "    for(uint q = 0; q < nq; q += get_local_size(0))\n"
  "    {\n"
  "      if((q + lid0) < nq)\n"
  "      {\n"
  "        float s, t;\n"
  "\n"
  "#ifndef USE_FLOAT\n"
  "        t  = convert_float(xq[q + lid0]);\n"
  "        s  = convert_float(xq[q + lid0 + nq]);\n"
  "\n"
  "        private float3 xx, yy;\n"
  "\n"
  "        xx = (1.0f - t) * convert_float3(x[xp[0]]) +\n"
  "             (t - s)    * convert_float3(x[xp[1]]) +\n"
  "             s          * convert_float3(x[xp[2]]);\n"
  "\n"
  "        t  = convert_float(yq[q + lid0]);\n"
  "        s  = convert_float(yq[q + lid0 + nq]);\n"
  "\n"
  "        yy = (1.0f - t) * convert_float3(y[yp[0]]) +\n"
  "             (t - s)    * convert_float3(y[yp[1]]) +\n"
  "             s          * convert_float3(y[yp[2]]);\n"
  "#else\n"
  "        // if(k == 0 && get_group_id(0) == 0) printf(\"%u: %.5e %.5e %.5e %.5e %.5e\\n\", q + lid0, xq[q + lid0], xq[q + lid0 + nq], yq[q + lid0], yq[q + lid0 + nq], wq[q + lid0]);\n"
  "\n"
  "        t  = xq[q + lid0];\n"
  "        s  = xq[q + lid0 + nq];\n"
  "\n"
  "        private float3 xx, yy;\n"
  "\n"
  "        xx = (r_one - t) * x[xp[0]] + (t - s) * x[xp[1]] + s * x[xp[2]];\n"
  "\n"
  "        t  = yq[q + lid0];\n"
  "        s  = yq[q + lid0 + nq];\n"
  "\n"
  "        yy = (r_one - t) * y[yp[0]] + (t - s) * y[yp[1]] + s * y[yp[2]];\n"
  "#endif\n"
  "\n"
  "        sum += wq[q + lid0] * laplace3d(xx, yy);\n"
  "      }\n"
  "    }\n"
  "\n"
  "    for(uint j = 0; j < get_local_size(0); ++j)\n"
  "    {\n"
  "      barrier(CLK_LOCAL_MEM_FENCE);\n"
  "\n"
  "      if(lid0 == j)\n"
  "        gcii->ytl[0] += factor * sum;\n"
  "    }\n"
  "\n"
  "    barrier(CLK_LOCAL_MEM_FENCE);\n"
  "\n"
  "    if(lid0 == 0)\n"
  "      gcii->yt[i] +=\n"
  "        alpha * xts[j] * (gcii->ytl[0] + (ii == jj) * 0.5 * bem_alpha * gr);\n"
  "  }\n"
  "}\n"
  "\n"
  "#endif // INTEGRALINFO_CL\n"
};

/** @} */

#endif // CLINTEGRALINFO_CL